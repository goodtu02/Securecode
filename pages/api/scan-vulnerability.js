export default async function handler(req, res) {
  if (req.method !== 'POST') {
    return res.status(405).json({ message: 'Method not allowed' });
  }

  try {
    const { code, language } = req.body;

    // 외부 AI 모델 API 호출
    const response = await fetch('https://n8ncloud12.app.n8n.cloud/webhook-test/front/input', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${process.env.AI_API_KEY}`, // 환경변수
      },
      body: JSON.stringify({
        code: code,
        task: 'vulnerability_scan',
        language: language || 'java'
      }),
    });

    // 항상 텍스트로 읽고 JSON/마크다운 순서로 파싱 시도
    const raw = await response.text();
    let parsed = null;
    try {
      parsed = JSON.parse(raw);
    } catch (_) {
      parsed = null;
    }

    // JSON인 경우에도 텍스트 필드에 마크다운이 들어 있을 수 있음
    let normalizedInput = null;

    // helper: output 래핑 해제 및 변환
    function unwrapOutput(obj) {
      if (!obj || typeof obj !== 'object') return null;
      const out = obj.output ?? obj.data?.output ?? obj.json?.output;
      if (out == null) return null;
      if (typeof out === 'string') {
        try {
          const fencedMatch = out.match(/```(?:json)?\n([\s\S]*?)\n```/i);
          const maybeJson = fencedMatch ? fencedMatch[1] : out;
          const inner = JSON.parse(maybeJson);
          if (inner && typeof inner === 'object') return inner;
        } catch (_) {}
        return parseMarkdownReport(out);
      }
      if (typeof out === 'object') return out;
      return null;
    }

    // helper: findings 리포트를 UI 스키마로 변환
    function convertFromFindingsReport(reportObj) {
      if (!reportObj || typeof reportObj !== 'object') return null;
      if (!Array.isArray(reportObj.findings)) return null;

      const vulnerabilities = reportObj.findings.map((f, idx) => {
        const sev = (f.severity || '').trim();
        const lineRange = f.evidence?.line_range || '';
        const lineMatch = typeof lineRange === 'string' && lineRange.match(/(\d+)/);
        const line = lineMatch ? parseInt(lineMatch[1], 10) : undefined;
        return {
          id: f.id ?? idx + 1,
          type: f.title || f.category || 'Vulnerability',
          severity: sev || 'High',
          line,
          description: f.description || `감지된 취약점: ${f.title || f.category}`,
          recommendation: f.recommendation || '',
          cwe: f.cwe || '',
        };
      });

      // report_markdown 파싱 (보조 신호)
      const parsedMd = typeof reportObj.report_markdown === 'string' ? parseMarkdownReport(reportObj.report_markdown) : null;

      // 추천 섹션 내 코드블록에서 수정 코드 우선 추출
      let fixedCode = '';
      for (const f of reportObj.findings) {
        if (typeof f.recommendation === 'string') {
          const codeBlock = f.recommendation.match(/```[a-zA-Z]*\n([\s\S]*?)\n```/);
          if (codeBlock && codeBlock[1]) { fixedCode = codeBlock[1]; break; }
        }
      }
      if (!fixedCode) {
        fixedCode = reportObj.findings.find((f) => f.evidence?.snippet_fixed)?.evidence?.snippet_fixed || '';
      }
      if (!fixedCode && parsedMd && typeof parsedMd.fixedCode === 'string') {
        fixedCode = parsedMd.fixedCode;
      }

      const guide = {
        title: '보안 권고',
        sections: []
      };
      if (reportObj.summary?.key_points && Array.isArray(reportObj.summary.key_points)) {
        guide.sections.push({
          title: '핵심 요약',
          content: reportObj.summary.key_points.join('\n'),
          priority: 'High'
        });
      }
      // 각 취약점의 권고를 섹션으로 추가
      for (const f of reportObj.findings) {
        if (typeof f.recommendation === 'string' && f.recommendation.trim()) {
          const content = f.recommendation.replace(/```[\s\S]*?```/g, '').trim();
          guide.sections.push({
            title: `${f.title || f.category || '권고'}`,
            content,
            priority: (f.severity || '').toLowerCase() === 'critical' ? 'Critical' : 'High'
          });
        }
      }
      // report_markdown에서 추가 섹션 병합
      if (parsedMd && parsedMd.guide && Array.isArray(parsedMd.guide.sections)) {
        for (const s of parsedMd.guide.sections) {
          if (s && s.title) guide.sections.push(s);
        }
      }
      // report_markdown의 보안 체크리스트 섹션 파싱
      if (typeof reportObj.report_markdown === 'string') {
        const text = reportObj.report_markdown.replace(/\r\n?/g, '\n');
        const start = text.indexOf('보안 체크리스트');
        if (start !== -1) {
          const listText = text.slice(start);
          const checklistItems = [...listText.matchAll(/\*\s*\[[ xX]?\]\s*\*\*(.*?)\*\*\s*:\s*([\s\S]*?)(?=\n\*|\n###|$)/g)];
          for (const m of checklistItems) {
            const title = (m[1] || '').trim();
            const content = (m[2] || '').trim();
            if (title) guide.sections.push({ title, content, priority: 'High' });
          }
        }
      }

      const sevStats = reportObj.stats?.by_severity || {};
      const stats = {
        totalIssues: reportObj.stats?.total_findings || vulnerabilities.length || 0,
        criticalIssues: sevStats.Critical || 0,
        highIssues: sevStats.High || 0,
        mediumIssues: sevStats.Medium || 0,
        lowIssues: sevStats.Low || 0,
        securityScore: 0,
      };
      if (stats.totalIssues > 0 && stats.securityScore === 0) {
        const penalty = stats.criticalIssues * 25 + stats.highIssues * 15 + stats.mediumIssues * 8 + stats.lowIssues * 3;
        stats.securityScore = Math.max(0, 100 - Math.min(100, penalty));
      }

      return { vulnerabilities, fixedCode, guide, stats };
    }

    if (Array.isArray(parsed)) {
      const first = parsed.find((item) => {
        if (!item) return false;
        if (typeof item === 'string') return true;
        return typeof item === 'object' && (item.output || item.content || item.text || item.report || item.markdown || item.data?.report || item.data?.content);
      });
      if (typeof first === 'object') {
        const unwrapped = unwrapOutput(first);
        if (unwrapped) {
          normalizedInput = convertFromFindingsReport(unwrapped) || unwrapped;
        } else {
          const md = first?.content || first?.text || first?.report || first?.markdown || first?.data?.report || first?.data?.content || '';
          normalizedInput = md ? parseMarkdownReport(String(md)) : {};
        }
      } else {
        const md = typeof first === 'string' ? first : '';
        normalizedInput = md ? parseMarkdownReport(String(md)) : {};
      }
    } else if (parsed && typeof parsed === 'object') {
      // 먼저 output 래핑 확인
      const unwrapped = unwrapOutput(parsed);
      if (unwrapped) {
        normalizedInput = convertFromFindingsReport(unwrapped) || unwrapped;
      } else if (Array.isArray(parsed.vulnerabilities) || typeof parsed.fixedCode === 'string' || parsed.guide || parsed.stats) {
        normalizedInput = parsed;
      } else if (parsed.findings) {
        normalizedInput = convertFromFindingsReport(parsed) || {};
      } else {
        const md = parsed.content || parsed.text || parsed.report || parsed.markdown || parsed.data?.report || parsed.data?.content || '';
        normalizedInput = md ? parseMarkdownReport(String(md)) : {};
      }
    } else {
      normalizedInput = parseMarkdownReport(raw);
    }

    // AI 결과를 프론트엔드 형식으로 변환
    const formattedResult = normalizeResult(normalizedInput);

    res.status(200).json(formattedResult);
  } catch (error) {
    console.error('API Error:', error);
    res.status(500).json({ message: 'Internal server error' });
  }
}

function normalizeResult(input) {
  const defaultStats = { totalIssues: 0, criticalIssues: 0, highIssues: 0, mediumIssues: 0, lowIssues: 0, securityScore: 0 };
  const vulnerabilities = Array.isArray(input?.vulnerabilities) ? input.vulnerabilities : [];
  const stats = input?.stats && typeof input.stats === 'object' ? input.stats : defaultStats;
  // 자동 통계 보정
  if (vulnerabilities.length > 0 && (stats.totalIssues || 0) === 0) {
    stats.totalIssues = vulnerabilities.length;
    stats.highIssues = vulnerabilities.filter(v => (v.severity || '').toLowerCase() === 'high').length;
    stats.criticalIssues = vulnerabilities.filter(v => (v.severity || '').toLowerCase() === 'critical').length;
    stats.mediumIssues = vulnerabilities.filter(v => (v.severity || '').toLowerCase() === 'medium').length;
    stats.lowIssues = vulnerabilities.filter(v => (v.severity || '').toLowerCase() === 'low').length;
    // 간단한 점수 추정: 100 - 가중치
    const penalty = stats.criticalIssues * 25 + stats.highIssues * 15 + stats.mediumIssues * 8 + stats.lowIssues * 3;
    stats.securityScore = Math.max(0, 100 - Math.min(100, penalty));
  }
  return {
    vulnerabilities,
    fixedCode: typeof input?.fixedCode === 'string' ? input.fixedCode : '',
    guide: input?.guide && typeof input.guide === 'object' ? input.guide : { title: '보안 가이드', sections: [] },
    stats,
  };
}

// 매우 단순한 마크다운 파서: 제공된 리포트 포맷을 가정하여 주요 정보를 추출
function parseMarkdownReport(md) {
  if (typeof md !== 'string') return {};

  const text = md.replace(/\r\n?/g, '\n');

  // 취약점 유형 추출 (예: SQL Injection)
  let vulnType = /SQL\s*Injection/i.test(text) ? 'SQL Injection' : undefined;

  // 취약 코드 라인 추출 (예: "취약 코드 위치: 9행")
  const lineMatch = text.match(/취약\s*코드\s*위치[^\d]*(\d+)\s*행/);
  const vulnLine = lineMatch ? parseInt(lineMatch[1], 10) : undefined;

  // 취약점 설명 추출
  let description = '';
  const descMatch = text.match(/취약점\s*설명:\s*([\s\S]*?)(?:\n\n|---|###|$)/);
  if (descMatch) description = descMatch[1].trim();

  // 권장사항/보안 개선점 (요약) 추출
  let recommendation = '';
  const recMatch = text.match(/보안\s*개선점:[\s\S]*?\n\s*1\.[\s\S]*?\n\s*\d\.[\s\S]*?|보안\s*권고:[\s\S]*/);
  if (recMatch) {
    const section = recMatch[0];
    const firstBulletMatch = section.match(/\n\s*\d+\.\s*\*\*(.*?)\*\*/);
    if (firstBulletMatch) recommendation = firstBulletMatch[1].trim();
  }

  // 수정 코드 추출: "수정 코드 분석" 섹션 내 첫 코드블록
  let fixedCode = '';
  const fixSectionStart = text.indexOf('수정 코드 분석');
  if (fixSectionStart !== -1) {
    const after = text.slice(fixSectionStart);
    const codeBlockMatch = after.match(/```[a-zA-Z]*\n([\s\S]*?)\n```/);
    if (codeBlockMatch) fixedCode = codeBlockMatch[1];
  }

  // 가이드 섹션(보안 권고) 추출: 각 번호 항목을 섹션으로
  const guide = { title: '보안 권고', sections: [] };
  const guideStart = text.indexOf('보안 권고');
  if (guideStart !== -1) {
    const guideText = text.slice(guideStart);
    const items = [...guideText.matchAll(/\n\s*(\d+)\.\s*\*\*(.*?)\*\*:?[\s\S]*?(?=\n\s*\d+\.|\n---|\n###|$)/g)];
    for (const m of items) {
      const title = m[2].trim();
      const contentMatch = m[0].match(/\*\*\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?\*?/);
      const content = contentMatch ? contentMatch[0].replace(/^[\s\S]*?\*\*.*?\*\*:?\s*/, '').trim() : '';
      guide.sections.push({ title, content, priority: title.toLowerCase().includes('의무') ? 'Critical' : 'High' });
    }
  }

  const vulnerabilities = [];
  if (vulnType) {
    vulnerabilities.push({
      id: 1,
      type: vulnType,
      severity: 'High',
      line: vulnLine || undefined,
      description: description || `${vulnType} 취약점이 감지되었습니다. 사용자 입력을 직접 쿼리에 연결하지 마세요.`,
      recommendation: recommendation || '매개변수화된 쿼리(Prepared Statement)를 사용하세요.',
      cwe: 'CWE-89',
    });
  }

  return {
    vulnerabilities,
    fixedCode,
    guide,
    stats: { totalIssues: vulnerabilities.length, criticalIssues: 0, highIssues: vulnerabilities.length, mediumIssues: 0, lowIssues: 0, securityScore: vulnerabilities.length ? 70 : 100 },
  };
}
